<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>ReactJS Technical Documentation</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/css/bootstrap.min.css"
      integrity="sha256-L/W5Wfqfa0sdBNIKN9cG6QA5F2qx4qICmU2VgLruv9Y="
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="./src/styles.css" />
  </head>
  <body>
    <div class="p-0">
      <header class="header fixed-top">
        <nav class="navbar container navbar-expand-sm px-4 px-sm-0">
          <a class="navbar-brand" href="#">
            <img
              class="brand-logo"
              src="./public/image/logo.svg"
              alt="ReactJS logo"
            />
          </a>
          <div class="connections">
            <input
              class="d-none d-sm-inline form-control col-3 my-3 my-sm-1"
              type="search"
              placeholder="Search"
            />
            <a href="https://codepen.io/amarjeetrao/" class="codepen">
              <svg
                class="social-icon"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 22.834"
              >
                <path
                  class="a"
                  d="M17.531,0H6.469A6.318,6.318,0,0,0,0,6.155V16.68a6.318,6.318,0,0,0,6.469,6.155H17.531A6.318,6.318,0,0,0,24,16.68V6.155A6.318,6.318,0,0,0,17.531,0Zm-.141,13a.827.827,0,0,1-.4.691l-4.552,2.859a.918.918,0,0,1-.966,0L7.008,13.745a.827.827,0,0,1-.4-.691V9.923a.832.832,0,0,1,.384-.682l4.387-2.908a.914.914,0,0,1,.984-.013l4.627,2.912a.827.827,0,0,1,.4.691Z"
                ></path>
              </svg>
            </a>
            <a href="https://github.com/Amarjeetrao" class="github">
              <svg
                class="social-icon"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 23.428"
              >
                <path
                  class="a"
                  d="M22.4,11.378a11.942,11.942,0,0,0-4.369-4.369A11.73,11.73,0,0,0,12.005,5.4,11.75,11.75,0,0,0,5.978,7.009a11.942,11.942,0,0,0-4.369,4.369A11.745,11.745,0,0,0,0,17.4a11.661,11.661,0,0,0,2.288,7.057,11.724,11.724,0,0,0,5.918,4.336.689.689,0,0,0,.624-.109.606.606,0,0,0,.2-.471c0-.033,0-.312-.005-.843s-.005-1-.005-1.391l-.361.06a4.406,4.406,0,0,1-.865.055,6.863,6.863,0,0,1-1.084-.109,2.376,2.376,0,0,1-1.046-.471,1.99,1.99,0,0,1-.69-.964l-.159-.361a3.965,3.965,0,0,0-.493-.8,1.886,1.886,0,0,0-.679-.591l-.109-.077a1.3,1.3,0,0,1-.2-.186.993.993,0,0,1-.142-.219c-.033-.071-.005-.131.077-.181a1.015,1.015,0,0,1,.454-.06l.312.049a2.232,2.232,0,0,1,.772.378,2.552,2.552,0,0,1,.755.81,2.756,2.756,0,0,0,.865.974,1.834,1.834,0,0,0,1.024.334,4.672,4.672,0,0,0,.892-.077,3.2,3.2,0,0,0,.7-.235A2.518,2.518,0,0,1,9.81,22.7a11.169,11.169,0,0,1-1.6-.279,6.424,6.424,0,0,1-1.467-.608A4.217,4.217,0,0,1,5.48,20.767a5.005,5.005,0,0,1-.821-1.642,7.794,7.794,0,0,1-.323-2.343,4.549,4.549,0,0,1,1.237-3.219,4.2,4.2,0,0,1,.109-3.186,2.2,2.2,0,0,1,1.347.214,9.423,9.423,0,0,1,1.3.6c.274.164.5.307.662.422a11.311,11.311,0,0,1,6,0l.591-.372a8.215,8.215,0,0,1,1.44-.69,2.008,2.008,0,0,1,1.265-.17,4.158,4.158,0,0,1,.126,3.186,4.573,4.573,0,0,1,1.237,3.219,7.894,7.894,0,0,1-.323,2.354,4.8,4.8,0,0,1-.827,1.642,4.379,4.379,0,0,1-1.265,1.04,6.282,6.282,0,0,1-1.467.608,10.341,10.341,0,0,1-1.6.279,2.785,2.785,0,0,1,.81,2.217v3.3a.628.628,0,0,0,.2.471.67.67,0,0,0,.619.109,11.787,11.787,0,0,0,5.918-4.336A11.661,11.661,0,0,0,24,17.411,11.7,11.7,0,0,0,22.4,11.378Z"
                  transform="translate(0 -5.4)"
                ></path>
              </svg>
            </a>
            <button
              class="navbar-toggler d-block d-lg-none"
              type="button"
              data-toggle="collapse"
              data-target="#navCollapse"
              aria-controls="navCollapse"
              aria-expanded="false"
              aria-label="Toggle navigation"
            >
              <span class="icon-toggler"></span>
            </button>
          </div>
        </nav>
      </header>
      <aside
        class="sidebar collapse navbar-collapse fixed-left d-lg-block pb-5"
        id="navCollapse"
      >
        <nav class="navbar flex-column p-0 pb-5" id="navbar">
          <header class="navbar-header align-self-start">
            Getting Familiar with ReactJS
          </header>
          <ul class="list-group w-100 pb-5">
            <li class="list-group-item px-4 px-lg-3">
              <a href="#Hello_World" class="nav-link sidebar-active"
                >Hello World</a
              >
            </li>
            <li class="list-group-item px-4 px-lg-3">
              <a href="#Introducing_JSX" class="nav-link">Introducing JSX</a>
            </li>
            <li class="list-group-item px-4 px-lg-3">
              <a href="#Rendering_Elements" class="nav-link"
                >Rendering Elements</a
              >
            </li>
            <li class="list-group-item px-4 px-lg-3">
              <a href="#Components_and_Props" class="nav-link"
                >Components and Props</a
              >
            </li>
            <li class="list-group-item px-4 px-lg-3">
              <a href="#State_and_Lifecycle" class="nav-link"
                >State and Lifecycle</a
              >
            </li>
            <li class="list-group-item px-4 px-lg-3">
              <a href="#Handling_Events" class="nav-link">Handling Events</a>
            </li>
            <li class="list-group-item px-4 px-lg-3">
              <a href="#Conditional_Rendering" class="nav-link"
                >Conditional Rendering</a
              >
            </li>
          </ul>
        </nav>
      </aside>
      <main class="main px-4 px-lg-0 mr-md-5" id="main-doc">
        <section class="main-section" id="Hello_World">
          <header class="section-header">
            <h1 class="section-heading">Hello World</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                The smallest React example looks like this:
              </p>
              <pre class="code-container">
<code class="code-example">
    ReactDOM.render(
      &lt;h1&gt;Hello, world!&lt;/h1&gt;,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                <a
                  class="article-link"
                  href="https://reactjs.org/redirect-to-codepen/hello-world"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                Click the link above to open an online editor. Feel free to make
                some changes, and see how they affect the output. Most pages in
                this guide will have editable examples like this one.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">How to Read This Guide</h2>
              <p>
                This is the first chapter in a step-by-step guide about main
                React concepts. You can find a list of all its chapters in the
                navigation sidebar. If you’re reading this from a mobile device,
                you can access the navigation by pressing the button in the
                bottom right corner of your screen.
              </p>
              <p>
                Every chapter in this guide builds on the knowledge introduced
                in earlier chapters.
                <strong
                  >You can learn most of React by reading the
                  <q>Main Concepts</q> guide chapters in the order they appear
                  in the sidebar.</strong
                >
                For example, <a href="#Introducing_JSX">Introducing JSX</a> is
                the next chapter after this one.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">Knowledge Level Assumptions</h2>
              <p>
                React is a JavaScript library, and so we’ll assume you have a
                basic understanding of the JavaScript language.
                <strong
                  >If you don’t feel very confident, we recommend
                  <a
                    href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript"
                    >going through a JavaScript tutorial</a
                  >
                  to check your knowledge level</strong
                >
                and enable you to follow along this guide without getting lost.
                It might take you between 30 minutes and an hour, but as a
                result you won’t have to feel like you’re learning both React
                and JavaScript at the same time.
              </p>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">Let’s Get Started!</h2>
              <p>
                Now you done with this page let go to the
                <a href="#Introducing_JSX">next chapter</a>.
              </p>
            </section>
          </article>
        </section>
        <section class="main-section" id="Introducing_JSX">
          <header class="section-header">
            <h1 class="section-heading">Introducing JSX</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                Consider this variable declaration:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code>
              </pre>
              <p>
                This funny tag syntax is neither a string nor HTML.
              </p>
              <p>
                It is called JSX, and it is a syntax extension to JavaScript. We
                recommend using it with React to describe what the UI should
                look like. JSX may remind you of a template language, but it
                comes with the full power of JavaScript.
              </p>
              <p>
                JSX produces React “elements”. We will explore rendering them to
                the DOM in the next section. Below, you can find the basics of
                JSX necessary to get you started.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">Why JSX?</h2>
              <p>
                React embraces the fact that rendering logic is inherently
                coupled with other UI logic: how events are handled, how the
                state changes over time, and how the data is prepared for
                display.
              </p>
              <p>
                Instead of artificially separating technologies by putting
                markup and logic in separate files, React separates concerns
                with loosely coupled units called <q>components</q> that contain
                both. We will come back to components in a further section, but
                if you’re not yet comfortable putting markup in JS, this talk
                might convince you otherwise.
              </p>
              <p>
                React doesn’t require using JSX, but most people find it helpful
                as a visual aid when working with UI inside the JavaScript code.
                It also allows React to show more useful error and warning
                messages.
              </p>
              <p>
                With that out of the way, let’s get started!
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">Embedding Expressions in JSX</h2>
              <p>
                In the example below, we declare a variable called name and then
                use it inside JSX by wrapping it in curly braces:
              </p>
              <pre class="code-container">
<code class="code-example">
    const name = 'Josh Perez';
    const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

    ReactDOM.render(
    element,
    document.getElementById('root')
    );</code>
              </pre>
              <p>
                You can put any valid JavaScript expression inside the curly
                braces in JSX. For example, 2 + 2, user.firstName, or
                formatName(user) are all valid JavaScript expressions.
              </p>
              <p>
                In the example below, we embed the result of calling a
                JavaScript function, formatName(user), into an &lt;h1&gt;
                element.
              </p>
              <pre class="code-container">
<code class="code-example">
    function formatName(user) {
    return user.firstName + ' ' + user.lastName;
    }

    const user = {
      firstName: 'Harper',
      lastName: 'Perez'
    };

    const element = (
      &lt;h1&gt;
        Hello, {formatName(user)}!
      &lt;/h&gt;
    );

    ReactDOM.render(
      element,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                <a
                  class="article-link"
                  href="https://reactjs.org/redirect-to-codepen/introducing-jsx"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                We split JSX over multiple lines for readability. While it isn’t
                required, when doing this, we also recommend wrapping it in
                parentheses to avoid the pitfalls of automatic semicolon
                insertion.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">JSX is an Expression Too</h2>
              <p>
                After compilation, JSX expressions become regular JavaScript
                function calls and evaluate to JavaScript objects.
              </p>
              <p>
                This means that you can use JSX inside of if statements and for
                loops, assign it to variables, accept it as arguments, and
                return it from functions:
              </p>
              <pre class="code-container">
<code class="code-example">
    function getGreeting(user) {
      if (user) {
        return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
      }
      return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
    }</code>
              </pre>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Specifying Attributes with JSX
              </h2>
              <p>
                You may use quotes to specify string literals as attributes:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;div tabIndex="0"&gt&lt;/div&gt;;</code>
              </pre>
              <p>
                You may also use curly braces to embed a JavaScript expression
                in an attribute:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code>
              </pre>
              <p>
                Don’t put quotes around curly braces when embedding a JavaScript
                expression in an attribute. You should either use quotes (for
                string values) or curly braces (for expressions), but not both
                in the same attribute.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Specifying Children with JSX
              </h2>
              <p>
                If a tag is empty, you may close it immediately with /&gt;, like
                XML:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;img src={user.avatarUrl} /&gt;;</code>
              </pre>
              <p>
                JSX tags may contain children:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = (
    &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
    &lt;/div&gt;
    );</code>
              </pre>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                JSX Prevents Injection Attacks
              </h2>
              <p>
                It is safe to embed user input in JSX:
              </p>
              <pre class="code-container">
<code class="code-example">
    const title = response.potentiallyMaliciousInput;
    // This is safe:
    const element = &gt;h1&gt;{title}&gt;/h1&gt;;</code>
              </pre>
              <p>
                By default, React DOM escapes any values embedded in JSX before
                rendering them. Thus it ensures that you can never inject
                anything that’s not explicitly written in your application.
                Everything is converted to a string before being rendered. This
                helps prevent XSS (cross-site-scripting) attacks.
              </p>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">
                JSX Represents Objects
              </h2>
              <p>
                Babel compiles JSX down to React.createElement() calls.
              </p>
              <p>
                These two examples are identical:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = (
      &lt;h1 className="greeting"&gt;
        Hello, world!
      &lt;/h1&gt;
    );</code>
              </pre>
              <pre class="code-container">
<code class="code-example">
    const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Hello, world!'
    );</code>
              </pre>
              <p>
                React.createElement() performs a few checks to help you write
                bug-free code but essentially it creates an object like this:
              </p>
              <pre class="code-container">
<code class="code-example">
    // Note: this structure is simplified
    const element = {
    type: 'h1',
    props: {
    className: 'greeting',
    children: 'Hello, world!'
      }
    };</code>
              </pre>
              <p>
                These objects are called “React elements”. You can think of them
                as descriptions of what you want to see on the screen. React
                reads these objects and uses them to construct the DOM and keep
                it up to date.
              </p>
              <p>
                We will explore rendering React elements to the DOM in the next
                section.
              </p>
            </section>
          </article>
        </section>
        <section class="main-section" id="Rendering_Elements">
          <header class="section-header">
            <h1 class="section-heading">Rendering Elements</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                Elements are the smallest building blocks of React apps.
              </p>
              <p>
                An element describes what you want to see on the screen:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</code>
              </pre>
              <p>
                Unlike browser DOM elements, React elements are plain objects,
                and are cheap to create. React DOM takes care of updating the
                DOM to match the React elements.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Rendering an Element into the DOM
              </h2>
              <p>
                Let’s say there is a &lt;div&gt; somewhere in your HTML file:
              </p>
              <pre class="code-container">
<code class="code-example">
    &lt;div id="root"&gt;&lt;/div&gt;</code>
              </pre>
              <p>
                We call this a “root” DOM node because everything inside it will
                be managed by React DOM.
              </p>
              <p>
                Applications built with just React usually have a single root
                DOM node. If you are integrating React into an existing app, you
                may have as many isolated root DOM nodes as you like.
              </p>
              <p>
                To render a React element into a root DOM node, pass both to
                ReactDOM.render():
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
    ReactDOM.render(element, document.getElementById('root'));</code>
              </pre>
              <p>
                It displays “Hello, world” on the page.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Updating the Rendered Element
              </h2>
              <p>
                React elements are immutable. Once you create an element, you
                can’t change its children or attributes. An element is like a
                single frame in a movie: it represents the UI at a certain point
                in time.
              </p>
              <p>
                With our knowledge so far, the only way to update the UI is to
                create a new element, and pass it to ReactDOM.render().
              </p>
              <p>
                Consider this ticking clock example:
              </p>
              <pre class="code-container">
<code class="code-example">
    function tick() {
    const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
      );
    ReactDOM.render(element, document.getElementById('root'));
    }

    setInterval(tick, 1000);</code>
              </pre>
              <p>
                It calls ReactDOM.render() every second from a setInterval()
                callback.
              </p>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">
                React Only Updates What’s Necessary
              </h2>
              <p>
                React DOM compares the element and its children to the previous
                one, and only applies the DOM updates necessary to bring the DOM
                to the desired state
              </p>
              <p>
                You can verify by inspecting the last example with the browser
                tools:
              </p>
              <img
                class="mb-4"
                src="https://reactjs.org/granular-dom-updates-c158617ed7cc0eac8f58330e49e48224.gif"
                alt="DOM inspector showing granular updates"
              />
              <p>
                Even though we create an element describing the whole UI tree on
                every tick, only the text node whose contents has changed gets
                updated by React DOM.
              </p>
              <p>
                In our experience, thinking about how the UI should look at any
                given moment rather than how to change it over time eliminates a
                whole class of bugs.
              </p>
            </section>
          </article>
        </section>
        <section class="main-section" id="Components_and_Props">
          <header class="section-header">
            <h1 class="section-heading">Components and Props</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                Components let you split the UI into independent, reusable
                pieces, and think about each piece in isolation. This page
                provides an introduction to the idea of components.
              </p>
              <p>
                Conceptually, components are like JavaScript functions. They
                accept arbitrary inputs (called “props”) and return React
                elements describing what should appear on the screen.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Function and Class Components
              </h2>
              <p>
                The simplest way to define a component is to write a JavaScript
                function:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
    }</code>
                </pre>
              <p>
                This function is a valid React component because it accepts a
                single “props” (which stands for properties) object argument
                with data and returns a React element. We call such components
                “function components” because they are literally JavaScript
                functions.
              </p>
              <p>
                You can also use an ES6 class to define a component:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
    }</code>
              </pre>
              <p>
                The above two components are equivalent from React’s point of
                view.
              </p>
              <p>
                Classes have some additional features that we will discuss in
                the next sections. Until then, we will use function components
                for their conciseness.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Rendering a Component
              </h2>
              <p>
                Previously, we only encountered React elements that represent
                DOM tags:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;div /&gt;;</code>
                </pre>
              <p>
                However, elements can also represent user-defined components:
              </p>
              <pre class="code-container">
<code class="code-example">
    const element = &lt;Welcome name="Sara" /&gt;;</code>
              </pre>
              <p>
                When React sees an element representing a user-defined
                component, it passes JSX attributes to this component as a
                single object. We call this object “props”.
              </p>
              <p>
                For example, this code renders “Hello, Sara” on the page:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
    }

    const element = &lt;Welcome name="Sara" /&gt;;
    ReactDOM.render(
      element,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                Let’s recap what happens in this example:
              </p>
              <ol start="1">
                <li>
                  We call ReactDOM.render() with the &lt;Welcome name="Sara"
                  /&gt; element.
                </li>
                <li>
                  React calls the Welcome component with {name: 'Sara'} as the
                  props.
                </li>
                <li>
                  Our Welcome component returns a &lt;h1&gt;Hello,
                  Sara&lt;/h1&gt; element as the result.
                </li>
                <li>
                  React DOM efficiently updates the DOM to match
                  &lt;h1&gt;Hello, Sara&lt;/h1&gt;.
                </li>
              </ol>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Composing Components
              </h2>
              <p>
                Components can refer to other components in their output. This
                lets us use the same component abstraction for any level of
                detail. A button, a form, a dialog, a screen: in React apps, all
                those are commonly expressed as components.
              </p>
              <p>
                For example, we can create an App component that renders Welcome
                many times:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
    }

    function App() {
      return (
        &lt;div&gt;
          &lt;Welcome name="Sara" /&gt;
          &lt;Welcome name="Cahal" /&gt;
          &lt;Welcome name="Edite" /&gt;
        &lt;/div&gt;
      );
    }

    ReactDOM.render(
      &lt;App /&gt;,
      document.getElementById('root')
    );</code>
                </pre>
              <p>
                Typically, new React apps have a single App component at the
                very top. However, if you integrate React into an existing app,
                you might start bottom-up with a small component like Button and
                gradually work your way to the top of the view hierarchy.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Extracting Components
              </h2>
              <p>
                Don’t be afraid to split components into smaller components.
              </p>
              <p>
                For example, consider this Comment component:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Comment(props) {
    return (
      &lt;div className="Comment"&gt;
        &lt;div className="UserInfo"&gt;
          &lt;img className="Avatar"
            src={props.author.avatarUrl}
            alt={props.author.name}
          /&gt;
          &lt;div className="UserInfo-name"&gt;
            {props.author.name}
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className="Comment-text"&gt;
          {props.text}
        &lt;/div&gt;
        &lt;div className="Comment-date"&gt;
          {formatDate(props.date)}
        &lt;/div&gt;
      &lt;/div&gt;
      );
    }</code>
                </pre>
              <p>
                It accepts author (an object), text (a string), and date (a
                date) as props, and describes a comment on a social media
                website.
              </p>
              <p>
                This component can be tricky to change because of all the
                nesting, and it is also hard to reuse individual parts of it.
                Let’s extract a few components from it.
              </p>
              <p>
                First, we will extract Avatar:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Avatar(props) {
    return (
      &lt;img className="Avatar"
        src={props.user.avatarUrl}
        alt={props.user.name}
      /&gt;
      );
    }</code>
                </pre>
              <p>
                The Avatar doesn’t need to know that it is being rendered inside
                a Comment. This is why we have given its prop a more generic
                name: user rather than author.
              </p>
              <p>
                We recommend naming props from the component’s own point of view
                rather than the context in which it is being used.
              </p>
              <p>
                We can now simplify Comment a tiny bit:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Comment(props) {
    return (
      &lt;div className="Comment"&gt;
        &lt;div className="UserInfo"&gt;
          &lt;Avatar user={props.author} /&gt;
          &lt;div className="UserInfo-name"&gt;
            {props.author.name}
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div className="Comment-text"&gt;
          {props.text}
        &lt;/div&gt;
        &lt;div className="Comment-date"&gt;
          {formatDate(props.date)}
        &lt;/div&gt;
      &lt;/div&gt;
      );
    }</code>
                </pre>
              <p>
                Next, we will extract a UserInfo component that renders an
                Avatar next to the user’s name:
              </p>
              <pre class="code-container">
<code class="code-example">
    function UserInfo(props) {
    return (
      &lt;div className="UserInfo"&gt;
        &lt;Avatar user={props.user} /&gt;
        &lt;div className="UserInfo-name"&gt;
          {props.user.name}
        &lt;/div&gt;
      &lt;/div&gt;
      );
    }</code>
                </pre>
              <p>
                This lets us simplify Comment even further:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Comment(props) {
    return (
      &lt;div className="Comment"&gt;
        &lt;UserInfo user={props.author} /&gt;
        &lt;div className="Comment-text"&gt;
          {props.text}
        &lt;/div&gt;
        &lt;div className="Comment-date"&gt;
          {formatDate(props.date)}
        &lt;/div&gt;
      &lt;/div&gt;
      );
    }</code>
                </pre>
              <p>
                <a
                  class="article-link"
                  href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components-continued"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                Extracting components might seem like grunt work at first, but
                having a palette of reusable components pays off in larger apps.
                A good rule of thumb is that if a part of your UI is used
                several times (Button, Panel, Avatar), or is complex enough on
                its own (App, FeedStory, Comment), it is a good candidate to be
                a reusable component.
              </p>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">
                Props are Read-Only
              </h2>
              <p>
                Whether you declare a component as a function or a class, it
                must never modify its own props. Consider this sum function:
              </p>
              <pre class="code-container">
<code class="code-example">
    function sum(a, b) {
    return a + b;
    }</code>
                </pre>
              <p>
                Such functions are called “pure” because they do not attempt to
                change their inputs, and always return the same result for the
                same inputs.
              </p>
              <p>
                In contrast, this function is impure because it changes its own
                input:
              </p>
              <pre class="code-container">
<code class="code-example">
    function withdraw(account, amount) {
    account.total -= amount;
    }</code>
                </pre>
              <p>
                React is pretty flexible but it has a single strict rule:
              </p>
              <p>
                <strong>
                  All React components must act like pure functions with respect
                  to their props.
                </strong>
              </p>
              <p>
                Of course, application UIs are dynamic and change over time. In
                the next section, we will introduce a new concept of “state”.
                State allows React components to change their output over time
                in response to user actions, network responses, and anything
                else, without violating this rule.
              </p>
            </section>
          </article>
        </section>
        <section class="main-section" id="State_and_Lifecycle">
          <header class="section-header">
            <h1 class="section-heading">State and Lifecycle</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                This page introduces the concept of state and lifecycle in a
                React component.
              </p>
              <p>
                Consider the ticking clock example from one of the previous
                sections. In Rendering Elements, we have only learned one way to
                update the UI. We call ReactDOM.render() to change the rendered
                output:
              </p>
              <pre class="code-container">
<code class="code-example">
    function tick() {
    const element = (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
      );
    ReactDOM.render(
      element,
      document.getElementById('root')
      );
    }

    setInterval(tick, 1000);</code>
                </pre>
              <p>
                In this section, we will learn how to make the Clock component
                truly reusable and encapsulated. It will set up its own timer
                and update itself every second.
              </p>
              <p>
                We can start by encapsulating how the clock looks:
              </p>
              <pre class="code-container">
<code class="code-example">
    function Clock(props) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
      );
    }

    function tick() {
      ReactDOM.render(
        &lt;Clock date={new Date()} /&gt;,
        document.getElementById('root')
      );
    }

    setInterval(tick, 1000);</code>
                </pre>
              <p>
                However, it misses a crucial requirement: the fact that the
                Clock sets up a timer and updates the UI every second should be
                an implementation detail of the Clock.
              </p>
              <p>
                Ideally we want to write this once and have the Clock update
                itself:
              </p>
              <pre class="code-container">
<code class="code-example">
    ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
    );</code>
                </pre>
              <p>
                To implement this, we need to add “state” to the Clock
                component.
              </p>
              <p>
                State is similar to props, but it is private and fully
                controlled by the component.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Converting a Function to a Class
              </h2>
              <p>
                You can convert a function component like Clock to a class in
                five steps:
              </p>
              <ol>
                <li>
                  Create an ES6 class, with the same name, that extends
                  React.Component.
                </li>
                <li>Add a single empty method to it called render().</li>
                <li>Move the body of the function into the render() method.</li>
                <li>Replace props with this.props in the render() body.</li>
                <li>Delete the remaining empty function declaration.</li>
              </ol>
              <pre class="code-container">
<code class="code-example">
    class Clock extends React.Component {
    render() {
      return (
        &lt;div&gt;
          &lt;h1&gt;Hello, world!&lt;/h1&gt;
          &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
        &lt;/div&gt;
        );
      }
    }</code>
                </pre>
              <p>Clock is now defined as a class rather than a function.</p>
              <p>
                The render method will be called each time an update happens,
                but as long as we render <Clock /> into the same DOM node, only
                a single instance of the Clock class will be used. This lets us
                use additional features such as local state and lifecycle
                methods.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Adding Local State to a Class
              </h2>
              <p>
                We will move the date from props to state in three steps:
              </p>
              <ol>
                <li>
                  Replace this.props.date with this.state.date in the render()
                  method:
                  <pre class="code-container">
<code class="code-example">
    class Clock extends React.Component {
    render() {
      return (
        &lt;div&gt;
          &lt;h1&gt;Hello, world!&lt;/h1&gt;
          &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
        &lt;/div&gt;
        );
      }
    }</code>
                </pre>
                </li>
                <li>
                  Add a class constructor that assigns the initial this.state:
                  <pre class="code-container">
<code class="code-example">
    class Clock extends React.Component {
    constructor(props) {
      super(props);
      this.state = {date: new Date()};
    }

    render() {
      return (
        &lt;div&gt;
          &lt;h1&gt;Hello, world!&lt;/h1&gt;
          &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
        &lt;/div&gt;
        );
      }
    }</code>
                </pre>
                  <p>Note how we pass props to the base constructor:</p>
                  <pre class="code-container">
<code class="code-example">
    constructor(props) {
      super(props);
      this.state = {date: new Date()};
    }</code>
                </pre>
                  <p>
                    Class components should always call the base constructor
                    with props.
                  </p>
                </li>
                <li>
                  Move the body of the function into the render() method.
                  <pre class="code-container">
<code class="code-example">
    ReactDOM.render(
    &lt;Clock /&gt;,
    document.getElementById('root')
    );</code>
                </pre>
                  <p>
                    We will later add the timer code back to the component
                    itself.
                  </p>
                </li>
              </ol>
              <p>The result looks like this:</p>
              <pre class="code-container">
<code class="code-example">
    class Clock extends React.Component {
    constructor(props) {
      super(props);
      this.state = {date: new Date()};
    }

    render() {
      return (
        &lt;div&gt;
          &lt;h1&gt;Hello, world!&lt;/h1&gt;
          &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
        &lt;/div&gt;
        );
      }
    }

    ReactDOM.render(
      &lt;Clock /&gt;,
      document.getElementById('root')
    );</code>
                </pre>
              <p>
                <a
                  class="article-link"
                  href="https://codepen.io/gaearon/pen/KgQpJd?editors=0010"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                Next, we’ll make the Clock set up its own timer and update
                itself every second.
              </p>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">
                Adding Lifecycle Methods to a Class
              </h2>
              <p>
                In applications with many components, it’s very important to
                free up resources taken by the components when they are
                destroyed.
              </p>
              <p>
                We want to set up a timer whenever the Clock is rendered to the
                DOM for the first time. This is called “mounting” in React.
              </p>
              <p>
                We also want to clear that timer whenever the DOM produced by
                the Clock is removed. This is called “unmounting” in React.
              </p>
              <p>
                We can declare special methods on the component class to run
                some code when a component mounts and unmounts:
              </p>
              <pre class="code-container"><code class="code-example">
    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = {date: new Date()};
      }

      componentDidMount() {

      }

      componentWillUnmount() {

      }

      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Hello, world!&lt;/h1&gt;
            &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
          &lt;/div&gt;
        );
      }
    }</code>
                </pre>
              <p>
                These methods are called “lifecycle methods”.
              </p>
              <p>
                The componentDidMount() method runs after the component output
                has been rendered to the DOM. This is a good place to set up a
                timer:
              </p>
              <pre class="code-container"><code class="code-example">
    componentDidMount() {
      this.timerID = setInterval(
        () => this.tick(),
        1000
      );
    }</code>
                </pre>
              <p>
                Note how we save the timer ID right on this (this.timerID).
              </p>
              <p>
                While this.props is set up by React itself and this.state has a
                special meaning, you are free to add additional fields to the
                class manually if you need to store something that doesn’t
                participate in the data flow (like a timer ID).
              </p>
              <p>
                We will tear down the timer in the componentWillUnmount()
                lifecycle method:
              </p>
              <pre class="code-container"><code class="code-example">
    componentWillUnmount() {
      clearInterval(this.timerID);
    }</code>
                </pre>
              <p>
                Finally, we will implement a method called tick() that the Clock
                component will run every second.
              </p>
              <p>
                It will use this.setState() to schedule updates to the component
                local state:
              </p>
              <pre class="code-container"><code class="code-example">
    class Clock extends React.Component {
      constructor(props) {
        super(props);
        this.state = {date: new Date()};
      }

      componentDidMount() {
        this.timerID = setInterval(
          () => this.tick(),
          1000
        );
      }

      componentWillUnmount() {
        clearInterval(this.timerID);
      }

      tick() {
        this.setState({
          date: new Date()
        });
      }

      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Hello, world!&lt;/h1&gt;
            &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
          &lt;/div&gt;
        );
      }
    }

    ReactDOM.render(
      &lt;Clock /&gt;,
      document.getElementById('root')
    );</code>
                </pre>
              <p>
                <a
                  class="article-link"
                  href="https://codepen.io/gaearon/pen/amqdNA?editors=0010"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                In React apps, whether a component is stateful or stateless is
                considered an implementation detail of the component that may
                change over time. You can use stateless components inside
                stateful components, and vice versa
              </p>
            </section>
          </article>
        </section>
        <section class="main-section" id="Handling_Events">
          <header class="section-header">
            <h1 class="section-heading">Handling Events</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                Handling events with React elements is very similar to handling
                events on DOM elements. There are some syntactic differences:
              </p>
              <ul>
                <li>
                  React events are named using camelCase, rather than lowercase.
                </li>
                <li>
                  With JSX you pass a function as the event handler, rather than
                  a string.
                </li>
              </ul>
              <p>
                For example, the HTML:
              </p>
              <pre class="code-container"><code class="code-example">
    &lt;button onclick="activateLasers()"&gt;
    Activate Lasers
    &lt;/button&gt;</code>
              </pre>
              <p>is slightly different in React:</p>
              <pre class="code-container"><code class="code-example">
    &lt;button onClick={activateLasers}&gt;
      Activate Lasers
    &lt;/button&gt;</code>
              </pre>
              <p>
                Another difference is that you cannot return false to prevent
                default behavior in React. You must call preventDefault
                explicitly. For example, with plain HTML, to prevent the default
                link behavior of opening a new page, you can write:
              </p>
              <pre class="code-container"><code class="code-example">
    &lt;a href="#" onclick="console.log('The link was clicked.'); return false"&gt;
      Click me
    &lt;/a&gt;</code>
              </pre>
              <p>
                In React, this could instead be:
              </p>
              <pre class="code-container"><code class="code-example">
    function ActionLink() {
      function handleClick(e) {
        e.preventDefault();
        console.log('The link was clicked.');
      }

      return (
        &lt;a href="#" onClick={handleClick}&gt;
          Click me
        &lt;/a&gt;
      );
    }</code>
              </pre>
              <p>
                Here, e is a synthetic event. React defines these synthetic
                events according to the W3C spec, so you don’t need to worry
                about cross-browser compatibility. See the SyntheticEvent
                reference guide to learn more.
              </p>
              <p>
                When using React you should generally not need to call
                addEventListener to add listeners to a DOM element after it is
                created. Instead, just provide a listener when the element is
                initially rendered.
              </p>
              <p>
                When you define a component using an ES6 class, a common pattern
                is for an event handler to be a method on the class. For
                example, this Toggle component renders a button that lets the
                user toggle between “ON” and “OFF” states:
              </p>
              <pre class="code-container"><code class="code-example">
    class Toggle extends React.Component {
      constructor(props) {
        super(props);
        this.state = {isToggleOn: true};

        // This binding is necessary to make `this` work in the callback
        this.handleClick = this.handleClick.bind(this);
      }

      handleClick() {
        this.setState(state => ({
          isToggleOn: !state.isToggleOn
        }));
      }

      render() {
        return (
          &lt;button onClick={this.handleClick}&gt;
            {this.state.isToggleOn ? 'ON' : 'OFF'}
          &lt;/button&gt;
        );
      }
    }

    ReactDOM.render(
      &lt;Toggle /&gt;,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                <a
                  class="article-link"
                  href="https://codepen.io/gaearon/pen/xEmzGg?editors=0010"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                If calling bind annoys you, there are two ways you can get
                around this. If you are using the experimental public class
                fields syntax, you can use class fields to correctly bind
                callbacks:
              </p>
              <pre class="code-container"><code class="code-example">
    class LoggingButton extends React.Component {
      // This syntax ensures `this` is bound within handleClick.
      // Warning: this is *experimental* syntax.
      handleClick = () => {
        console.log('this is:', this);
      }

      render() {
        return (
          &lt;button onClick={this.handleClick}&gt;
            Click me
          &lt;/button&gt;
        );
      }
    }</code>
              </pre>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">
                Passing Arguments to Event Handlers
              </h2>
              <p>
                Inside a loop it is common to want to pass an extra parameter to
                an event handler. For example, if id is the row ID, either of
                the following would work:
              </p>
              <pre class="code-container"><code class="code-example">
    &lt;button onClick={(e) => this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
    &lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;</code>
              </pre>
              <p>
                The above two lines are equivalent, and use arrow functions and
                Function.prototype.bind respectively.
              </p>
              <p>
                In both cases, the e argument representing the React event will
                be passed as a second argument after the ID. With an arrow
                function, we have to pass it explicitly, but with bind any
                further arguments are automatically forwarded.
              </p>
            </section>
          </article>
        </section>
        <section class="main-section" id="Conditional_Rendering">
          <header class="section-header">
            <h1 class="section-heading">Conditional Rendering</h1>
          </header>
          <article class="section-content">
            <section class="article-sections">
              <p class="article-overview my-4">
                In React, you can create distinct components that encapsulate
                behavior you need. Then, you can render only some of them,
                depending on the state of your application.
              </p>
              <p>
                Conditional rendering in React works the same way conditions
                work in JavaScript. Use JavaScript operators like if or the
                conditional operator to create elements representing the current
                state, and let React update the UI to match them.
              </p>
              <p>Consider these two components:</p>
              <pre class="code-container"><code class="code-example">
    function UserGreeting(props) {
      return &lt;h1&gt;Welcome back!&lt;/h1&gt;;
    }

    function GuestGreeting(props) {
      return &lt;h1&gt;Please sign up.&lt;/h1&gt;;
    }</code>
              </pre>
              <p>
                We’ll create a Greeting component that displays either of these
                components depending on whether a user is logged in:
              </p>
              <pre class="code-container"><code class="code-example">
    function Greeting(props) {
      const isLoggedIn = props.isLoggedIn;
      if (isLoggedIn) {
        return &lt;UserGreeting /&gt;;
      }
      return &lt;GuestGreeting /&gt;;
    }

    ReactDOM.render(
      // Try changing to isLoggedIn={true}:
      &lt;Greeting isLoggedIn={false} /&gt;,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                This example renders a different greeting depending on the value
                of isLoggedIn prop.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">Element Variables</h2>
              <p>
                You can use variables to store elements. This can help you
                conditionally render a part of the component while the rest of
                the output doesn’t change.
              </p>
              <p>
                Consider these two new components representing Logout and Login
                buttons:
              </p>
              <pre class="code-container"><code class="code-example">
    function LoginButton(props) {
      return (
        &lt;button onClick={props.onClick}&gt;
          Login
        &lt;/button&gt;
      );
    }

    function LogoutButton(props) {
      return (
        &lt;button onClick={props.onClick}&gt;
          Logout
        &lt;/button&gt;
      );
    }</code>
              </pre>
              <p>
                In the example below, we will create a stateful component called
                LoginControl.
              </p>
              <p>
                It will render either &lt;LoginButton /&gt; or &lt;LogoutButton
                /&gt; depending on its current state. It will also render a
                &lt;Greeting /&gt; from the previous example:
              </p>
              <pre class="code-container"><code class="code-example">
    class LoginControl extends React.Component {
      constructor(props) {
        super(props);
        this.handleLoginClick = this.handleLoginClick.bind(this);
        this.handleLogoutClick = this.handleLogoutClick.bind(this);
        this.state = {isLoggedIn: false};
      }

      handleLoginClick() {
        this.setState({isLoggedIn: true});
      }

      handleLogoutClick() {
        this.setState({isLoggedIn: false});
      }

      render() {
        const isLoggedIn = this.state.isLoggedIn;
        let button;

        if (isLoggedIn) {
          button = &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;;
        } else {
          button = &lt;LoginButton onClick={this.handleLoginClick} /&gt;;
        }

        return (
          &lt;div&gt;
            &lt;Greeting isLoggedIn={isLoggedIn} /&gt;
            {button}
          &lt;/div&gt;
        );
      }
    }

    ReactDOM.render(
      &lt;LoginControl /&gt;,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                <a
                  class="article-link"
                  href="https://codepen.io/gaearon/pen/QKzAgB?editors=0010"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                While declaring a variable and using an if statement is a fine
                way to conditionally render a component, sometimes you might
                want to use a shorter syntax. There are a few ways to inline
                conditions in JSX, explained below.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Inline If with Logical && Operator
              </h2>
              <p>
                You may embed any expressions in JSX by wrapping them in curly
                braces. This includes the JavaScript logical && operator. It can
                be handy for conditionally including an element:
              </p>
              <pre class="code-container"><code class="code-example">
    function Mailbox(props) {
      const unreadMessages = props.unreadMessages;
      return (
        &lt;div&gt;
          &lt;h1&gt;Hello!&lt;/h1&gt;
          {unreadMessages.length &gt; 0 &&
            &lt;h2&gt;
              You have {unreadMessages.length} unread messages.
            &lt;/h2&gt;
          }
        &lt;/div&gt;
      );
    }

    const messages = ['React', 'Re: React', 'Re:Re: React'];
    ReactDOM.render(
      &lt;Mailbox unreadMessages={messages} /&gt;,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                It works because in JavaScript, true && expression always
                evaluates to expression, and false && expression always
                evaluates to false.
              </p>
              <p>
                Therefore, if the condition is true, the element right after &&
                will appear in the output. If it is false, React will ignore and
                skip it.
              </p>
            </section>
            <section class="article-sections py-2">
              <h2 class="article-heading my-4">
                Inline If-Else with Conditional Operator
              </h2>
              <p>
                Another method for conditionally rendering elements inline is to
                use the JavaScript conditional operator condition ? true :
                false.
              </p>
              <p>
                In the example below, we use it to conditionally render a small
                block of text.
              </p>
              <pre class="code-container"><code class="code-example">
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        &lt;div&gt;
          The user is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.
        &lt;/div&gt;
      );
    }</code>
              </pre>
              <p>
                It can also be used for larger expressions although it is less
                obvious what’s going on:
              </p>
              <pre class="code-container"><code class="code-example">
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        &lt;div&gt;
          {isLoggedIn ? (
            &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
          ) : (
            &lt;LoginButton onClick={this.handleLoginClick} /&gt;
          )}
        &lt;/div&gt;
      );
    }</code>
              </pre>
              <p>
                Just like in JavaScript, it is up to you to choose an
                appropriate style based on what you and your team consider more
                readable. Also remember that whenever conditions become too
                complex, it might be a good time to extract a component.
              </p>
            </section>
            <section class="article-sections last-article-section py-2">
              <h2 class="article-heading my-4">
                Preventing Component from Rendering
              </h2>
              <p>
                In rare cases you might want a component to hide itself even
                though it was rendered by another component. To do this return
                null instead of its render output.
              </p>
              <p>
                In the example below, the &lt;WarningBanner /&gt; is rendered
                depending on the value of the prop called warn. If the value of
                the prop is false, then the component does not render:
              </p>
              <pre class="code-container">
    <code class="code-example">
    function WarningBanner(props) {
      if (!props.warn) {
        return null;
      }

      return (
        &lt;div className="warning"&gt;
          Warning!
        &lt;/div&gt;
      );
    }

    class Page extends React.Component {
      constructor(props) {
        super(props);
        this.state = {showWarning: true};
        this.handleToggleClick = this.handleToggleClick.bind(this);
      }

      handleToggleClick() {
        this.setState(state =&gt; ({
          showWarning: !state.showWarning
        }));
      }

      render() {
        return (
          &lt;div&gt;
            &lt;WarningBanner warn={this.state.showWarning} /&gt;
            &lt;button onClick={this.handleToggleClick}&gt;
              {this.state.showWarning ? 'Hide' : 'Show'}
            &lt;/button&gt;
          &lt;/div&gt;
        );
      }
    }

    ReactDOM.render(
      &lt;Page /&gt;,
      document.getElementById('root')
    );</code>
              </pre>
              <p>
                It can also be used for larger expressions although it is less
                obvious what’s going on:
              </p>
              <pre class="code-container">
    <code class="code-example">
    render() {
      const isLoggedIn = this.state.isLoggedIn;
      return (
        &lt;div&gt;
          {isLoggedIn ? (
            &lt;LogoutButton onClick={this.handleLogoutClick} /&gt;
          ) : (
            &lt;LoginButton onClick={this.handleLoginClick} /&gt;
          )}
        &lt;/div&gt;
      );
    }</code>
              </pre>
              <p>
                <a
                  class="article-link"
                  href="https://codepen.io/gaearon/pen/Xjoqwm?editors=0010"
                  target="_blank"
                  >Try it on CodePen</a
                >
              </p>
              <p>
                Returning null from a component’s render method does not affect
                the firing of the component’s lifecycle methods. For instance
                componentDidUpdate will still be called.
              </p>
            </section>
          </article>
        </section>
      </main>
    </div>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.4.1/js/bootstrap.bundle.min.js"
      integrity="sha256-OUFW7hFO0/r5aEGTQOz9F/aXQOt+TwqI1Z4fbVvww04="
      crossorigin="anonymous"
    ></script>
    <script src="./src/script.js"></script>
  </body>
</html>
